{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport { ArrayQueue } from '../../../../base/common/arrays.js';\nimport './glyphMargin.css';\nimport { DynamicViewOverlay } from '../../view/dynamicViewOverlay.js';\nimport { ViewPart } from '../../view/viewPart.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { GlyphMarginLane } from '../../../common/model.js';\n/**\n * Represents a decoration that should be shown along the lines from `startLineNumber` to `endLineNumber`.\n * This can end up producing multiple `LineDecorationToRender`.\n */\nexport class DecorationToRender {\n  constructor(startLineNumber, endLineNumber, className, tooltip, zIndex) {\n    this.startLineNumber = startLineNumber;\n    this.endLineNumber = endLineNumber;\n    this.className = className;\n    this.tooltip = tooltip;\n    this._decorationToRenderBrand = undefined;\n    this.zIndex = zIndex !== null && zIndex !== void 0 ? zIndex : 0;\n  }\n}\n/**\n * A decoration that should be shown along a line.\n */\nexport class LineDecorationToRender {\n  constructor(className, zIndex, tooltip) {\n    this.className = className;\n    this.zIndex = zIndex;\n    this.tooltip = tooltip;\n  }\n}\n/**\n * Decorations to render on a visible line.\n */\nexport class VisibleLineDecorationsToRender {\n  constructor() {\n    this.decorations = [];\n  }\n  add(decoration) {\n    this.decorations.push(decoration);\n  }\n  getDecorations() {\n    return this.decorations;\n  }\n}\nexport class DedupOverlay extends DynamicViewOverlay {\n  /**\n   * Returns an array with an element for each visible line number.\n   */\n  _render(visibleStartLineNumber, visibleEndLineNumber, decorations) {\n    const output = [];\n    for (let lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {\n      const lineIndex = lineNumber - visibleStartLineNumber;\n      output[lineIndex] = new VisibleLineDecorationsToRender();\n    }\n    if (decorations.length === 0) {\n      return output;\n    }\n    // Sort decorations by className, then by startLineNumber and then by endLineNumber\n    decorations.sort((a, b) => {\n      if (a.className === b.className) {\n        if (a.startLineNumber === b.startLineNumber) {\n          return a.endLineNumber - b.endLineNumber;\n        }\n        return a.startLineNumber - b.startLineNumber;\n      }\n      return a.className < b.className ? -1 : 1;\n    });\n    let prevClassName = null;\n    let prevEndLineIndex = 0;\n    for (let i = 0, len = decorations.length; i < len; i++) {\n      const d = decorations[i];\n      const className = d.className;\n      const zIndex = d.zIndex;\n      let startLineIndex = Math.max(d.startLineNumber, visibleStartLineNumber) - visibleStartLineNumber;\n      const endLineIndex = Math.min(d.endLineNumber, visibleEndLineNumber) - visibleStartLineNumber;\n      if (prevClassName === className) {\n        // Here we avoid rendering the same className multiple times on the same line\n        startLineIndex = Math.max(prevEndLineIndex + 1, startLineIndex);\n        prevEndLineIndex = Math.max(prevEndLineIndex, endLineIndex);\n      } else {\n        prevClassName = className;\n        prevEndLineIndex = endLineIndex;\n      }\n      for (let i = startLineIndex; i <= prevEndLineIndex; i++) {\n        output[i].add(new LineDecorationToRender(className, zIndex, d.tooltip));\n      }\n    }\n    return output;\n  }\n}\nexport class GlyphMarginWidgets extends ViewPart {\n  constructor(context) {\n    super(context);\n    this._widgets = {};\n    this._context = context;\n    const options = this._context.configuration.options;\n    const layoutInfo = options.get(143 /* EditorOption.layoutInfo */);\n    this.domNode = createFastDomNode(document.createElement('div'));\n    this.domNode.setClassName('glyph-margin-widgets');\n    this.domNode.setPosition('absolute');\n    this.domNode.setTop(0);\n    this._lineHeight = options.get(66 /* EditorOption.lineHeight */);\n    this._glyphMargin = options.get(57 /* EditorOption.glyphMargin */);\n    this._glyphMarginLeft = layoutInfo.glyphMarginLeft;\n    this._glyphMarginWidth = layoutInfo.glyphMarginWidth;\n    this._glyphMarginDecorationLaneCount = layoutInfo.glyphMarginDecorationLaneCount;\n    this._managedDomNodes = [];\n    this._decorationGlyphsToRender = [];\n  }\n  dispose() {\n    this._managedDomNodes = [];\n    this._decorationGlyphsToRender = [];\n    this._widgets = {};\n    super.dispose();\n  }\n  getWidgets() {\n    return Object.values(this._widgets);\n  }\n  // --- begin event handlers\n  onConfigurationChanged(e) {\n    const options = this._context.configuration.options;\n    const layoutInfo = options.get(143 /* EditorOption.layoutInfo */);\n    this._lineHeight = options.get(66 /* EditorOption.lineHeight */);\n    this._glyphMargin = options.get(57 /* EditorOption.glyphMargin */);\n    this._glyphMarginLeft = layoutInfo.glyphMarginLeft;\n    this._glyphMarginWidth = layoutInfo.glyphMarginWidth;\n    this._glyphMarginDecorationLaneCount = layoutInfo.glyphMarginDecorationLaneCount;\n    return true;\n  }\n  onDecorationsChanged(e) {\n    return true;\n  }\n  onFlushed(e) {\n    return true;\n  }\n  onLinesChanged(e) {\n    return true;\n  }\n  onLinesDeleted(e) {\n    return true;\n  }\n  onLinesInserted(e) {\n    return true;\n  }\n  onScrollChanged(e) {\n    return e.scrollTopChanged;\n  }\n  onZonesChanged(e) {\n    return true;\n  }\n  // --- end event handlers\n  // --- begin widget management\n  addWidget(widget) {\n    const domNode = createFastDomNode(widget.getDomNode());\n    this._widgets[widget.getId()] = {\n      widget: widget,\n      preference: widget.getPosition(),\n      domNode: domNode,\n      renderInfo: null\n    };\n    domNode.setPosition('absolute');\n    domNode.setDisplay('none');\n    domNode.setAttribute('widgetId', widget.getId());\n    this.domNode.appendChild(domNode);\n    this.setShouldRender();\n  }\n  setWidgetPosition(widget, preference) {\n    const myWidget = this._widgets[widget.getId()];\n    if (myWidget.preference.lane === preference.lane && myWidget.preference.zIndex === preference.zIndex && Range.equalsRange(myWidget.preference.range, preference.range)) {\n      return false;\n    }\n    myWidget.preference = preference;\n    this.setShouldRender();\n    return true;\n  }\n  removeWidget(widget) {\n    var _a;\n    const widgetId = widget.getId();\n    if (this._widgets[widgetId]) {\n      const widgetData = this._widgets[widgetId];\n      const domNode = widgetData.domNode.domNode;\n      delete this._widgets[widgetId];\n      (_a = domNode.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(domNode);\n      this.setShouldRender();\n    }\n  }\n  // --- end widget management\n  _collectDecorationBasedGlyphRenderRequest(ctx, requests) {\n    var _a, _b, _c;\n    const visibleStartLineNumber = ctx.visibleRange.startLineNumber;\n    const visibleEndLineNumber = ctx.visibleRange.endLineNumber;\n    const decorations = ctx.getDecorationsInViewport();\n    for (const d of decorations) {\n      const glyphMarginClassName = d.options.glyphMarginClassName;\n      if (!glyphMarginClassName) {\n        continue;\n      }\n      const startLineNumber = Math.max(d.range.startLineNumber, visibleStartLineNumber);\n      const endLineNumber = Math.min(d.range.endLineNumber, visibleEndLineNumber);\n      const lane = (_b = (_a = d.options.glyphMargin) === null || _a === void 0 ? void 0 : _a.position) !== null && _b !== void 0 ? _b : GlyphMarginLane.Center;\n      const zIndex = (_c = d.options.zIndex) !== null && _c !== void 0 ? _c : 0;\n      for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n        const modelPosition = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new Position(lineNumber, 0));\n        const laneIndex = this._context.viewModel.glyphLanes.getLanesAtLine(modelPosition.lineNumber).indexOf(lane);\n        requests.push(new DecorationBasedGlyphRenderRequest(lineNumber, laneIndex, zIndex, glyphMarginClassName));\n      }\n    }\n  }\n  _collectWidgetBasedGlyphRenderRequest(ctx, requests) {\n    const visibleStartLineNumber = ctx.visibleRange.startLineNumber;\n    const visibleEndLineNumber = ctx.visibleRange.endLineNumber;\n    for (const widget of Object.values(this._widgets)) {\n      const range = widget.preference.range;\n      const {\n        startLineNumber,\n        endLineNumber\n      } = this._context.viewModel.coordinatesConverter.convertModelRangeToViewRange(Range.lift(range));\n      if (!startLineNumber || !endLineNumber || endLineNumber < visibleStartLineNumber || startLineNumber > visibleEndLineNumber) {\n        // The widget is not in the viewport\n        continue;\n      }\n      // The widget is in the viewport, find a good line for it\n      const widgetLineNumber = Math.max(startLineNumber, visibleStartLineNumber);\n      const modelPosition = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new Position(widgetLineNumber, 0));\n      const laneIndex = this._context.viewModel.glyphLanes.getLanesAtLine(modelPosition.lineNumber).indexOf(widget.preference.lane);\n      requests.push(new WidgetBasedGlyphRenderRequest(widgetLineNumber, laneIndex, widget.preference.zIndex, widget));\n    }\n  }\n  _collectSortedGlyphRenderRequests(ctx) {\n    const requests = [];\n    this._collectDecorationBasedGlyphRenderRequest(ctx, requests);\n    this._collectWidgetBasedGlyphRenderRequest(ctx, requests);\n    // sort requests by lineNumber ASC, lane  ASC, zIndex DESC, type DESC (widgets first), className ASC\n    // don't change this sort unless you understand `prepareRender` below.\n    requests.sort((a, b) => {\n      if (a.lineNumber === b.lineNumber) {\n        if (a.laneIndex === b.laneIndex) {\n          if (a.zIndex === b.zIndex) {\n            if (b.type === a.type) {\n              if (a.type === 0 /* GlyphRenderRequestType.Decoration */ && b.type === 0 /* GlyphRenderRequestType.Decoration */) {\n                return a.className < b.className ? -1 : 1;\n              }\n              return 0;\n            }\n            return b.type - a.type;\n          }\n          return b.zIndex - a.zIndex;\n        }\n        return a.laneIndex - b.laneIndex;\n      }\n      return a.lineNumber - b.lineNumber;\n    });\n    return requests;\n  }\n  /**\n   * Will store render information in each widget's renderInfo and in `_decorationGlyphsToRender`.\n   */\n  prepareRender(ctx) {\n    if (!this._glyphMargin) {\n      this._decorationGlyphsToRender = [];\n      return;\n    }\n    for (const widget of Object.values(this._widgets)) {\n      widget.renderInfo = null;\n    }\n    const requests = new ArrayQueue(this._collectSortedGlyphRenderRequests(ctx));\n    const decorationGlyphsToRender = [];\n    while (requests.length > 0) {\n      const first = requests.peek();\n      if (!first) {\n        // not possible\n        break;\n      }\n      // Requests are sorted by lineNumber and lane, so we read all requests for this particular location\n      const requestsAtLocation = requests.takeWhile(el => el.lineNumber === first.lineNumber && el.laneIndex === first.laneIndex);\n      if (!requestsAtLocation || requestsAtLocation.length === 0) {\n        // not possible\n        break;\n      }\n      const winner = requestsAtLocation[0];\n      if (winner.type === 0 /* GlyphRenderRequestType.Decoration */) {\n        // combine all decorations with the same z-index\n        const classNames = [];\n        // requests are sorted by zIndex, type, and className so we can dedup className by looking at the previous one\n        for (const request of requestsAtLocation) {\n          if (request.zIndex !== winner.zIndex || request.type !== winner.type) {\n            break;\n          }\n          if (classNames.length === 0 || classNames[classNames.length - 1] !== request.className) {\n            classNames.push(request.className);\n          }\n        }\n        decorationGlyphsToRender.push(winner.accept(classNames.join(' '))); // TODO@joyceerhl Implement overflow for remaining decorations\n      } else {\n        // widgets cannot be combined\n        winner.widget.renderInfo = {\n          lineNumber: winner.lineNumber,\n          laneIndex: winner.laneIndex\n        };\n      }\n    }\n    this._decorationGlyphsToRender = decorationGlyphsToRender;\n  }\n  render(ctx) {\n    if (!this._glyphMargin) {\n      for (const widget of Object.values(this._widgets)) {\n        widget.domNode.setDisplay('none');\n      }\n      while (this._managedDomNodes.length > 0) {\n        const domNode = this._managedDomNodes.pop();\n        domNode === null || domNode === void 0 ? void 0 : domNode.domNode.remove();\n      }\n      return;\n    }\n    const width = Math.round(this._glyphMarginWidth / this._glyphMarginDecorationLaneCount);\n    // Render widgets\n    for (const widget of Object.values(this._widgets)) {\n      if (!widget.renderInfo) {\n        // this widget is not visible\n        widget.domNode.setDisplay('none');\n      } else {\n        const top = ctx.viewportData.relativeVerticalOffset[widget.renderInfo.lineNumber - ctx.viewportData.startLineNumber];\n        const left = this._glyphMarginLeft + widget.renderInfo.laneIndex * this._lineHeight;\n        widget.domNode.setDisplay('block');\n        widget.domNode.setTop(top);\n        widget.domNode.setLeft(left);\n        widget.domNode.setWidth(width);\n        widget.domNode.setHeight(this._lineHeight);\n      }\n    }\n    // Render decorations, reusing previous dom nodes as possible\n    for (let i = 0; i < this._decorationGlyphsToRender.length; i++) {\n      const dec = this._decorationGlyphsToRender[i];\n      const top = ctx.viewportData.relativeVerticalOffset[dec.lineNumber - ctx.viewportData.startLineNumber];\n      const left = this._glyphMarginLeft + dec.laneIndex * this._lineHeight;\n      let domNode;\n      if (i < this._managedDomNodes.length) {\n        domNode = this._managedDomNodes[i];\n      } else {\n        domNode = createFastDomNode(document.createElement('div'));\n        this._managedDomNodes.push(domNode);\n        this.domNode.appendChild(domNode);\n      }\n      domNode.setClassName(`cgmr codicon ` + dec.combinedClassName);\n      domNode.setPosition(`absolute`);\n      domNode.setTop(top);\n      domNode.setLeft(left);\n      domNode.setWidth(width);\n      domNode.setHeight(this._lineHeight);\n    }\n    // remove extra dom nodes\n    while (this._managedDomNodes.length > this._decorationGlyphsToRender.length) {\n      const domNode = this._managedDomNodes.pop();\n      domNode === null || domNode === void 0 ? void 0 : domNode.domNode.remove();\n    }\n  }\n}\n/**\n * A request to render a decoration in the glyph margin at a certain location.\n */\nclass DecorationBasedGlyphRenderRequest {\n  constructor(lineNumber, laneIndex, zIndex, className) {\n    this.lineNumber = lineNumber;\n    this.laneIndex = laneIndex;\n    this.zIndex = zIndex;\n    this.className = className;\n    this.type = 0 /* GlyphRenderRequestType.Decoration */;\n  }\n  accept(combinedClassName) {\n    return new DecorationBasedGlyph(this.lineNumber, this.laneIndex, combinedClassName);\n  }\n}\n/**\n * A request to render a widget in the glyph margin at a certain location.\n */\nclass WidgetBasedGlyphRenderRequest {\n  constructor(lineNumber, laneIndex, zIndex, widget) {\n    this.lineNumber = lineNumber;\n    this.laneIndex = laneIndex;\n    this.zIndex = zIndex;\n    this.widget = widget;\n    this.type = 1 /* GlyphRenderRequestType.Widget */;\n  }\n}\nclass DecorationBasedGlyph {\n  constructor(lineNumber, laneIndex, combinedClassName) {\n    this.lineNumber = lineNumber;\n    this.laneIndex = laneIndex;\n    this.combinedClassName = combinedClassName;\n  }\n}","map":{"version":3,"names":["createFastDomNode","ArrayQueue","DynamicViewOverlay","ViewPart","Position","Range","GlyphMarginLane","DecorationToRender","constructor","startLineNumber","endLineNumber","className","tooltip","zIndex","_decorationToRenderBrand","undefined","LineDecorationToRender","VisibleLineDecorationsToRender","decorations","add","decoration","push","getDecorations","DedupOverlay","_render","visibleStartLineNumber","visibleEndLineNumber","output","lineNumber","lineIndex","length","sort","a","b","prevClassName","prevEndLineIndex","i","len","d","startLineIndex","Math","max","endLineIndex","min","GlyphMarginWidgets","context","_widgets","_context","options","configuration","layoutInfo","get","domNode","document","createElement","setClassName","setPosition","setTop","_lineHeight","_glyphMargin","_glyphMarginLeft","glyphMarginLeft","_glyphMarginWidth","glyphMarginWidth","_glyphMarginDecorationLaneCount","glyphMarginDecorationLaneCount","_managedDomNodes","_decorationGlyphsToRender","dispose","getWidgets","Object","values","onConfigurationChanged","e","onDecorationsChanged","onFlushed","onLinesChanged","onLinesDeleted","onLinesInserted","onScrollChanged","scrollTopChanged","onZonesChanged","addWidget","widget","getDomNode","getId","preference","getPosition","renderInfo","setDisplay","setAttribute","appendChild","setShouldRender","setWidgetPosition","myWidget","lane","equalsRange","range","removeWidget","_a","widgetId","widgetData","parentNode","removeChild","_collectDecorationBasedGlyphRenderRequest","ctx","requests","_b","_c","visibleRange","getDecorationsInViewport","glyphMarginClassName","glyphMargin","position","Center","modelPosition","viewModel","coordinatesConverter","convertViewPositionToModelPosition","laneIndex","glyphLanes","getLanesAtLine","indexOf","DecorationBasedGlyphRenderRequest","_collectWidgetBasedGlyphRenderRequest","convertModelRangeToViewRange","lift","widgetLineNumber","WidgetBasedGlyphRenderRequest","_collectSortedGlyphRenderRequests","type","prepareRender","decorationGlyphsToRender","first","peek","requestsAtLocation","takeWhile","el","winner","classNames","request","accept","join","render","pop","remove","width","round","top","viewportData","relativeVerticalOffset","left","setLeft","setWidth","setHeight","dec","combinedClassName","DecorationBasedGlyph"],"sources":["D:/yupi/OJ System/OJ System/feioj-front/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/glyphMargin/glyphMargin.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport { ArrayQueue } from '../../../../base/common/arrays.js';\nimport './glyphMargin.css';\nimport { DynamicViewOverlay } from '../../view/dynamicViewOverlay.js';\nimport { ViewPart } from '../../view/viewPart.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { GlyphMarginLane } from '../../../common/model.js';\n/**\n * Represents a decoration that should be shown along the lines from `startLineNumber` to `endLineNumber`.\n * This can end up producing multiple `LineDecorationToRender`.\n */\nexport class DecorationToRender {\n    constructor(startLineNumber, endLineNumber, className, tooltip, zIndex) {\n        this.startLineNumber = startLineNumber;\n        this.endLineNumber = endLineNumber;\n        this.className = className;\n        this.tooltip = tooltip;\n        this._decorationToRenderBrand = undefined;\n        this.zIndex = zIndex !== null && zIndex !== void 0 ? zIndex : 0;\n    }\n}\n/**\n * A decoration that should be shown along a line.\n */\nexport class LineDecorationToRender {\n    constructor(className, zIndex, tooltip) {\n        this.className = className;\n        this.zIndex = zIndex;\n        this.tooltip = tooltip;\n    }\n}\n/**\n * Decorations to render on a visible line.\n */\nexport class VisibleLineDecorationsToRender {\n    constructor() {\n        this.decorations = [];\n    }\n    add(decoration) {\n        this.decorations.push(decoration);\n    }\n    getDecorations() {\n        return this.decorations;\n    }\n}\nexport class DedupOverlay extends DynamicViewOverlay {\n    /**\n     * Returns an array with an element for each visible line number.\n     */\n    _render(visibleStartLineNumber, visibleEndLineNumber, decorations) {\n        const output = [];\n        for (let lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {\n            const lineIndex = lineNumber - visibleStartLineNumber;\n            output[lineIndex] = new VisibleLineDecorationsToRender();\n        }\n        if (decorations.length === 0) {\n            return output;\n        }\n        // Sort decorations by className, then by startLineNumber and then by endLineNumber\n        decorations.sort((a, b) => {\n            if (a.className === b.className) {\n                if (a.startLineNumber === b.startLineNumber) {\n                    return a.endLineNumber - b.endLineNumber;\n                }\n                return a.startLineNumber - b.startLineNumber;\n            }\n            return (a.className < b.className ? -1 : 1);\n        });\n        let prevClassName = null;\n        let prevEndLineIndex = 0;\n        for (let i = 0, len = decorations.length; i < len; i++) {\n            const d = decorations[i];\n            const className = d.className;\n            const zIndex = d.zIndex;\n            let startLineIndex = Math.max(d.startLineNumber, visibleStartLineNumber) - visibleStartLineNumber;\n            const endLineIndex = Math.min(d.endLineNumber, visibleEndLineNumber) - visibleStartLineNumber;\n            if (prevClassName === className) {\n                // Here we avoid rendering the same className multiple times on the same line\n                startLineIndex = Math.max(prevEndLineIndex + 1, startLineIndex);\n                prevEndLineIndex = Math.max(prevEndLineIndex, endLineIndex);\n            }\n            else {\n                prevClassName = className;\n                prevEndLineIndex = endLineIndex;\n            }\n            for (let i = startLineIndex; i <= prevEndLineIndex; i++) {\n                output[i].add(new LineDecorationToRender(className, zIndex, d.tooltip));\n            }\n        }\n        return output;\n    }\n}\nexport class GlyphMarginWidgets extends ViewPart {\n    constructor(context) {\n        super(context);\n        this._widgets = {};\n        this._context = context;\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(143 /* EditorOption.layoutInfo */);\n        this.domNode = createFastDomNode(document.createElement('div'));\n        this.domNode.setClassName('glyph-margin-widgets');\n        this.domNode.setPosition('absolute');\n        this.domNode.setTop(0);\n        this._lineHeight = options.get(66 /* EditorOption.lineHeight */);\n        this._glyphMargin = options.get(57 /* EditorOption.glyphMargin */);\n        this._glyphMarginLeft = layoutInfo.glyphMarginLeft;\n        this._glyphMarginWidth = layoutInfo.glyphMarginWidth;\n        this._glyphMarginDecorationLaneCount = layoutInfo.glyphMarginDecorationLaneCount;\n        this._managedDomNodes = [];\n        this._decorationGlyphsToRender = [];\n    }\n    dispose() {\n        this._managedDomNodes = [];\n        this._decorationGlyphsToRender = [];\n        this._widgets = {};\n        super.dispose();\n    }\n    getWidgets() {\n        return Object.values(this._widgets);\n    }\n    // --- begin event handlers\n    onConfigurationChanged(e) {\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(143 /* EditorOption.layoutInfo */);\n        this._lineHeight = options.get(66 /* EditorOption.lineHeight */);\n        this._glyphMargin = options.get(57 /* EditorOption.glyphMargin */);\n        this._glyphMarginLeft = layoutInfo.glyphMarginLeft;\n        this._glyphMarginWidth = layoutInfo.glyphMarginWidth;\n        this._glyphMarginDecorationLaneCount = layoutInfo.glyphMarginDecorationLaneCount;\n        return true;\n    }\n    onDecorationsChanged(e) {\n        return true;\n    }\n    onFlushed(e) {\n        return true;\n    }\n    onLinesChanged(e) {\n        return true;\n    }\n    onLinesDeleted(e) {\n        return true;\n    }\n    onLinesInserted(e) {\n        return true;\n    }\n    onScrollChanged(e) {\n        return e.scrollTopChanged;\n    }\n    onZonesChanged(e) {\n        return true;\n    }\n    // --- end event handlers\n    // --- begin widget management\n    addWidget(widget) {\n        const domNode = createFastDomNode(widget.getDomNode());\n        this._widgets[widget.getId()] = {\n            widget: widget,\n            preference: widget.getPosition(),\n            domNode: domNode,\n            renderInfo: null\n        };\n        domNode.setPosition('absolute');\n        domNode.setDisplay('none');\n        domNode.setAttribute('widgetId', widget.getId());\n        this.domNode.appendChild(domNode);\n        this.setShouldRender();\n    }\n    setWidgetPosition(widget, preference) {\n        const myWidget = this._widgets[widget.getId()];\n        if (myWidget.preference.lane === preference.lane\n            && myWidget.preference.zIndex === preference.zIndex\n            && Range.equalsRange(myWidget.preference.range, preference.range)) {\n            return false;\n        }\n        myWidget.preference = preference;\n        this.setShouldRender();\n        return true;\n    }\n    removeWidget(widget) {\n        var _a;\n        const widgetId = widget.getId();\n        if (this._widgets[widgetId]) {\n            const widgetData = this._widgets[widgetId];\n            const domNode = widgetData.domNode.domNode;\n            delete this._widgets[widgetId];\n            (_a = domNode.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(domNode);\n            this.setShouldRender();\n        }\n    }\n    // --- end widget management\n    _collectDecorationBasedGlyphRenderRequest(ctx, requests) {\n        var _a, _b, _c;\n        const visibleStartLineNumber = ctx.visibleRange.startLineNumber;\n        const visibleEndLineNumber = ctx.visibleRange.endLineNumber;\n        const decorations = ctx.getDecorationsInViewport();\n        for (const d of decorations) {\n            const glyphMarginClassName = d.options.glyphMarginClassName;\n            if (!glyphMarginClassName) {\n                continue;\n            }\n            const startLineNumber = Math.max(d.range.startLineNumber, visibleStartLineNumber);\n            const endLineNumber = Math.min(d.range.endLineNumber, visibleEndLineNumber);\n            const lane = (_b = (_a = d.options.glyphMargin) === null || _a === void 0 ? void 0 : _a.position) !== null && _b !== void 0 ? _b : GlyphMarginLane.Center;\n            const zIndex = (_c = d.options.zIndex) !== null && _c !== void 0 ? _c : 0;\n            for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n                const modelPosition = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new Position(lineNumber, 0));\n                const laneIndex = this._context.viewModel.glyphLanes.getLanesAtLine(modelPosition.lineNumber).indexOf(lane);\n                requests.push(new DecorationBasedGlyphRenderRequest(lineNumber, laneIndex, zIndex, glyphMarginClassName));\n            }\n        }\n    }\n    _collectWidgetBasedGlyphRenderRequest(ctx, requests) {\n        const visibleStartLineNumber = ctx.visibleRange.startLineNumber;\n        const visibleEndLineNumber = ctx.visibleRange.endLineNumber;\n        for (const widget of Object.values(this._widgets)) {\n            const range = widget.preference.range;\n            const { startLineNumber, endLineNumber } = this._context.viewModel.coordinatesConverter.convertModelRangeToViewRange(Range.lift(range));\n            if (!startLineNumber || !endLineNumber || endLineNumber < visibleStartLineNumber || startLineNumber > visibleEndLineNumber) {\n                // The widget is not in the viewport\n                continue;\n            }\n            // The widget is in the viewport, find a good line for it\n            const widgetLineNumber = Math.max(startLineNumber, visibleStartLineNumber);\n            const modelPosition = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new Position(widgetLineNumber, 0));\n            const laneIndex = this._context.viewModel.glyphLanes.getLanesAtLine(modelPosition.lineNumber).indexOf(widget.preference.lane);\n            requests.push(new WidgetBasedGlyphRenderRequest(widgetLineNumber, laneIndex, widget.preference.zIndex, widget));\n        }\n    }\n    _collectSortedGlyphRenderRequests(ctx) {\n        const requests = [];\n        this._collectDecorationBasedGlyphRenderRequest(ctx, requests);\n        this._collectWidgetBasedGlyphRenderRequest(ctx, requests);\n        // sort requests by lineNumber ASC, lane  ASC, zIndex DESC, type DESC (widgets first), className ASC\n        // don't change this sort unless you understand `prepareRender` below.\n        requests.sort((a, b) => {\n            if (a.lineNumber === b.lineNumber) {\n                if (a.laneIndex === b.laneIndex) {\n                    if (a.zIndex === b.zIndex) {\n                        if (b.type === a.type) {\n                            if (a.type === 0 /* GlyphRenderRequestType.Decoration */ && b.type === 0 /* GlyphRenderRequestType.Decoration */) {\n                                return (a.className < b.className ? -1 : 1);\n                            }\n                            return 0;\n                        }\n                        return b.type - a.type;\n                    }\n                    return b.zIndex - a.zIndex;\n                }\n                return a.laneIndex - b.laneIndex;\n            }\n            return a.lineNumber - b.lineNumber;\n        });\n        return requests;\n    }\n    /**\n     * Will store render information in each widget's renderInfo and in `_decorationGlyphsToRender`.\n     */\n    prepareRender(ctx) {\n        if (!this._glyphMargin) {\n            this._decorationGlyphsToRender = [];\n            return;\n        }\n        for (const widget of Object.values(this._widgets)) {\n            widget.renderInfo = null;\n        }\n        const requests = new ArrayQueue(this._collectSortedGlyphRenderRequests(ctx));\n        const decorationGlyphsToRender = [];\n        while (requests.length > 0) {\n            const first = requests.peek();\n            if (!first) {\n                // not possible\n                break;\n            }\n            // Requests are sorted by lineNumber and lane, so we read all requests for this particular location\n            const requestsAtLocation = requests.takeWhile((el) => el.lineNumber === first.lineNumber && el.laneIndex === first.laneIndex);\n            if (!requestsAtLocation || requestsAtLocation.length === 0) {\n                // not possible\n                break;\n            }\n            const winner = requestsAtLocation[0];\n            if (winner.type === 0 /* GlyphRenderRequestType.Decoration */) {\n                // combine all decorations with the same z-index\n                const classNames = [];\n                // requests are sorted by zIndex, type, and className so we can dedup className by looking at the previous one\n                for (const request of requestsAtLocation) {\n                    if (request.zIndex !== winner.zIndex || request.type !== winner.type) {\n                        break;\n                    }\n                    if (classNames.length === 0 || classNames[classNames.length - 1] !== request.className) {\n                        classNames.push(request.className);\n                    }\n                }\n                decorationGlyphsToRender.push(winner.accept(classNames.join(' '))); // TODO@joyceerhl Implement overflow for remaining decorations\n            }\n            else {\n                // widgets cannot be combined\n                winner.widget.renderInfo = {\n                    lineNumber: winner.lineNumber,\n                    laneIndex: winner.laneIndex,\n                };\n            }\n        }\n        this._decorationGlyphsToRender = decorationGlyphsToRender;\n    }\n    render(ctx) {\n        if (!this._glyphMargin) {\n            for (const widget of Object.values(this._widgets)) {\n                widget.domNode.setDisplay('none');\n            }\n            while (this._managedDomNodes.length > 0) {\n                const domNode = this._managedDomNodes.pop();\n                domNode === null || domNode === void 0 ? void 0 : domNode.domNode.remove();\n            }\n            return;\n        }\n        const width = (Math.round(this._glyphMarginWidth / this._glyphMarginDecorationLaneCount));\n        // Render widgets\n        for (const widget of Object.values(this._widgets)) {\n            if (!widget.renderInfo) {\n                // this widget is not visible\n                widget.domNode.setDisplay('none');\n            }\n            else {\n                const top = ctx.viewportData.relativeVerticalOffset[widget.renderInfo.lineNumber - ctx.viewportData.startLineNumber];\n                const left = this._glyphMarginLeft + widget.renderInfo.laneIndex * this._lineHeight;\n                widget.domNode.setDisplay('block');\n                widget.domNode.setTop(top);\n                widget.domNode.setLeft(left);\n                widget.domNode.setWidth(width);\n                widget.domNode.setHeight(this._lineHeight);\n            }\n        }\n        // Render decorations, reusing previous dom nodes as possible\n        for (let i = 0; i < this._decorationGlyphsToRender.length; i++) {\n            const dec = this._decorationGlyphsToRender[i];\n            const top = ctx.viewportData.relativeVerticalOffset[dec.lineNumber - ctx.viewportData.startLineNumber];\n            const left = this._glyphMarginLeft + dec.laneIndex * this._lineHeight;\n            let domNode;\n            if (i < this._managedDomNodes.length) {\n                domNode = this._managedDomNodes[i];\n            }\n            else {\n                domNode = createFastDomNode(document.createElement('div'));\n                this._managedDomNodes.push(domNode);\n                this.domNode.appendChild(domNode);\n            }\n            domNode.setClassName(`cgmr codicon ` + dec.combinedClassName);\n            domNode.setPosition(`absolute`);\n            domNode.setTop(top);\n            domNode.setLeft(left);\n            domNode.setWidth(width);\n            domNode.setHeight(this._lineHeight);\n        }\n        // remove extra dom nodes\n        while (this._managedDomNodes.length > this._decorationGlyphsToRender.length) {\n            const domNode = this._managedDomNodes.pop();\n            domNode === null || domNode === void 0 ? void 0 : domNode.domNode.remove();\n        }\n    }\n}\n/**\n * A request to render a decoration in the glyph margin at a certain location.\n */\nclass DecorationBasedGlyphRenderRequest {\n    constructor(lineNumber, laneIndex, zIndex, className) {\n        this.lineNumber = lineNumber;\n        this.laneIndex = laneIndex;\n        this.zIndex = zIndex;\n        this.className = className;\n        this.type = 0 /* GlyphRenderRequestType.Decoration */;\n    }\n    accept(combinedClassName) {\n        return new DecorationBasedGlyph(this.lineNumber, this.laneIndex, combinedClassName);\n    }\n}\n/**\n * A request to render a widget in the glyph margin at a certain location.\n */\nclass WidgetBasedGlyphRenderRequest {\n    constructor(lineNumber, laneIndex, zIndex, widget) {\n        this.lineNumber = lineNumber;\n        this.laneIndex = laneIndex;\n        this.zIndex = zIndex;\n        this.widget = widget;\n        this.type = 1 /* GlyphRenderRequestType.Widget */;\n    }\n}\nclass DecorationBasedGlyph {\n    constructor(lineNumber, laneIndex, combinedClassName) {\n        this.lineNumber = lineNumber;\n        this.laneIndex = laneIndex;\n        this.combinedClassName = combinedClassName;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}