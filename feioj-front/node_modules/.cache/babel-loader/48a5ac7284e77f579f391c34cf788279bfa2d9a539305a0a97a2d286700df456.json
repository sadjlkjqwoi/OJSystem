{"ast":null,"code":"import \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { GlyphMarginLane } from '../model.js';\nconst MAX_LANE = GlyphMarginLane.Right;\nexport class GlyphMarginLanesModel {\n  constructor(maxLine) {\n    this.persist = 0;\n    this._requiredLanes = 1; // always render at least one lane\n    this.lanes = new Uint8Array(Math.ceil((maxLine + 1) * MAX_LANE / 8));\n  }\n  reset(maxLine) {\n    const bytes = Math.ceil((maxLine + 1) * MAX_LANE / 8);\n    if (this.lanes.length < bytes) {\n      this.lanes = new Uint8Array(bytes);\n    } else {\n      this.lanes.fill(0);\n    }\n    this._requiredLanes = 1;\n  }\n  get requiredLanes() {\n    return this._requiredLanes;\n  }\n  push(lane, range, persist) {\n    if (persist) {\n      this.persist |= 1 << lane - 1;\n    }\n    for (let i = range.startLineNumber; i <= range.endLineNumber; i++) {\n      const bit = MAX_LANE * i + (lane - 1);\n      this.lanes[bit >>> 3] |= 1 << bit % 8;\n      this._requiredLanes = Math.max(this._requiredLanes, this.countAtLine(i));\n    }\n  }\n  getLanesAtLine(lineNumber) {\n    const lanes = [];\n    let bit = MAX_LANE * lineNumber;\n    for (let i = 0; i < MAX_LANE; i++) {\n      if (this.persist & 1 << i || this.lanes[bit >>> 3] & 1 << bit % 8) {\n        lanes.push(i + 1);\n      }\n      bit++;\n    }\n    return lanes.length ? lanes : [GlyphMarginLane.Center];\n  }\n  countAtLine(lineNumber) {\n    let bit = MAX_LANE * lineNumber;\n    let count = 0;\n    for (let i = 0; i < MAX_LANE; i++) {\n      if (this.persist & 1 << i || this.lanes[bit >>> 3] & 1 << bit % 8) {\n        count++;\n      }\n      bit++;\n    }\n    return count;\n  }\n}","map":{"version":3,"names":["GlyphMarginLane","MAX_LANE","Right","GlyphMarginLanesModel","constructor","maxLine","persist","_requiredLanes","lanes","Uint8Array","Math","ceil","reset","bytes","length","fill","requiredLanes","push","lane","range","i","startLineNumber","endLineNumber","bit","max","countAtLine","getLanesAtLine","lineNumber","Center","count"],"sources":["D:/PersonalFiles/yupi/OJSystem/OJSystem/feioj-front/node_modules/monaco-editor/esm/vs/editor/common/viewModel/glyphLanesModel.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { GlyphMarginLane } from '../model.js';\nconst MAX_LANE = GlyphMarginLane.Right;\nexport class GlyphMarginLanesModel {\n    constructor(maxLine) {\n        this.persist = 0;\n        this._requiredLanes = 1; // always render at least one lane\n        this.lanes = new Uint8Array(Math.ceil(((maxLine + 1) * MAX_LANE) / 8));\n    }\n    reset(maxLine) {\n        const bytes = Math.ceil(((maxLine + 1) * MAX_LANE) / 8);\n        if (this.lanes.length < bytes) {\n            this.lanes = new Uint8Array(bytes);\n        }\n        else {\n            this.lanes.fill(0);\n        }\n        this._requiredLanes = 1;\n    }\n    get requiredLanes() {\n        return this._requiredLanes;\n    }\n    push(lane, range, persist) {\n        if (persist) {\n            this.persist |= (1 << (lane - 1));\n        }\n        for (let i = range.startLineNumber; i <= range.endLineNumber; i++) {\n            const bit = (MAX_LANE * i) + (lane - 1);\n            this.lanes[bit >>> 3] |= (1 << (bit % 8));\n            this._requiredLanes = Math.max(this._requiredLanes, this.countAtLine(i));\n        }\n    }\n    getLanesAtLine(lineNumber) {\n        const lanes = [];\n        let bit = MAX_LANE * lineNumber;\n        for (let i = 0; i < MAX_LANE; i++) {\n            if (this.persist & (1 << i) || this.lanes[bit >>> 3] & (1 << (bit % 8))) {\n                lanes.push(i + 1);\n            }\n            bit++;\n        }\n        return lanes.length ? lanes : [GlyphMarginLane.Center];\n    }\n    countAtLine(lineNumber) {\n        let bit = MAX_LANE * lineNumber;\n        let count = 0;\n        for (let i = 0; i < MAX_LANE; i++) {\n            if (this.persist & (1 << i) || this.lanes[bit >>> 3] & (1 << (bit % 8))) {\n                count++;\n            }\n            bit++;\n        }\n        return count;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}